120분
65% correct required to pass

OCAJP (70문항 150분) - Java 명령어 중심 출제
- Java Basics (Java 기초)- Working With Java Data Types (Java 데이터 유형 작업) - Using Operators and Decision Constructs (연산자 및 의사 결정 구성 사용)- Creating and Using Arrays (배열 생성 및 작업)- Using Loop Constructs (루프 구성 사용)- Working with Methods and Encapsulation (메소드 및 캡슐화 작업)- Working with Inheritance (상속 작업)- Handling Exceptions (예외 처리)- Working with Selected classes from the Java API (Java API에서 선택한 클래스로 작업) 
출처: https://xzio.tistory.com/2081 [어제보다 성장한 오늘:티스토리]



Review exam topics
Java Basics 

Define the scope of variables 
Define the structure of a Java class
Create executable Java applications with a main method; run a Java program from the command line; produce console output
Import other Java packages to make them accessible in your code
Compare and contrast the features and components of Java such as: platform independence, object orientation, encapsulation, etc.
Working With Java Data Types 

Declare and initialize variables (including casting of primitive data types)
Differentiate between object reference variables and primitive variables
Know how to read or write to object fields
Explain an Object's Lifecycle (creation, "dereference by reassignment" and garbage collection)
Develop code that uses wrapper classes such as Boolean, Double, and Integer  
Using Operators and Decision Constructs 

Use Java operators; use parentheses to override operator precedence
Test equality between Strings and other objects using == and equals ()
Create if and if/else and ternary constructs 
Use a switch statement 
Creating and Using Arrays 

Declare, instantiate, initialize and use a one-dimensional array
Declare, instantiate, initialize and use multi-dimensional arrays
Using Loop Constructs 

Create and use while loops
Create and use for loops including the enhanced for loop
Create and use do/while loops
Compare loop constructs
Use break and continue  
Working with Methods and Encapsulation 

Create methods with arguments and return values; including overloaded methods
Apply the static keyword to methods and fields  
Create and overload constructors; differentiate between default and user defined constructors
Apply access modifiers
Apply encapsulation principles to a class
Determine the effect upon object references and primitive values when they are passed  into methods that change the values
Working with Inheritance 

Describe inheritance and its benefits
Develop code that makes use of polymorphism; develop code that overrides methods;  differentiate between the type of a reference and the type of an object
Determine when casting is necessary
Use super and this to access objects and constructors
Use abstract classes and interfaces
Handling Exceptions 

Differentiate among checked exceptions, unchecked exceptions, and Errors
Create a try-catch block and determine how exceptions alter normal program flow
Describe the advantages of Exception handling 
Create and invoke a method that throws an exception
Recognize common exception classes (such as NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ClassCastException)
Working with Selected classes from the Java API 

Manipulate data using the StringBuilder class and its methods
Create and manipulate Strings
Create and manipulate calendar data using classes from java.time.LocalDateTime,  java.time.LocalDate, java.time.LocalTime, java.time.format.DateTimeFormatter, java.time.Period
Declare and use an ArrayList of a given type 
Write a simple Lambda expression that consumes a Lambda Predicate expression
Assume the following:

Missing package and import statements: If sample code do not include package or import statements, and the question does not explicitly refer to these missing statements, then assume that all sample code is in the same package, or import statements exist to support them.
No file or directory path names for classes: If a question does not state the file names or directory locations of classes, then assume one of the following, whichever will enable the code to compile and run:
All classes are in one file
Each class is contained in a separate file, and all files are in one directory
Unintended line breaks: Sample code might have unintended line breaks. If you see a line of code that looks like it has wrapped, and this creates a situation where the wrapping is significant (for example, a quoted String literal has wrapped), assume that the wrapping is an extension of the same line, and the line does not contain a hard carriage return that would cause a compilation failure.
Code fragments: A code fragment is a small section of source code that is presented without its context. Assume that all necessary supporting code exists and that the supporting environment fully supports the correct compilation and execution of the code shown and its omitted environment.
Descriptive comments: Take descriptive comments, such as "setter and getters go here," at face value. Assume that correct code exists, compiles, and runs successfully to create the described effect.



■ Java OCA Test Exam I - 53% correct (102/191)
 worst3
   1. Inheritance (24 questions) - 33% / 63% / 4%
   2. Data Types (20 questions) - 40% / 60%
   3. Methods & Encapsulation (26 questions) - 46% / 54%


□ Java OCA Test Exam I - Attempt 3: 74% correct (142/191)

Java Basics (18 questions) - 89% / 11%
Data Types (20 questions) - 90% / 10%
Operators & Decision Constructs (20 questions) - 80% /20%
Arrays (14 questions) - 86% / 14%
Loops (21 questions) - 81% / 19%
Methods & Encapsulation (26 questions) - 73% / 27%

worst 3
Inheritance (24 questions) - 58% / 42%
Exceptions (20 questions) - 60% / 40%
Java API (27 questions) - 63% / 37%


■ Java OCA Test Exam II - 54% correct (105/10)
worst3
  1. Java API (27 questions) - 26% / 74%
  2. Inheritance (25 questions) - 32% / 64% / 4%
  3. Exceptions (21 questions) - 38% / 57% / 5%

추후 검토
80, Q3121 
9, Q3134
100, Q3118
136, Q3140

■ Java OCA Test Exam III - 59% correct (114/191)
worst3
  1. Methods & Encapsulation (25 questions) - 36% / 64%
  2. Java API (28 questions) - 50% / 50%
  3. Data Types (22 questions) - 55% / 45%

Domains
Java Basics (18 questions) - 78% / 22%
Data Types (22 questions) - 55% / 45%
Operators & Decision Constructs (19 questions) - 79% / 21%
Arrays (13 questions) - 62% / 38%
Loops (22 questions) - 64% / 36%
Methods & Encapsulation (25 questions) - 36% / 64%
Inheritance (24 questions) - 63% / 37%
Exceptions (20 questions) - 65% / 35%
Java API (28 questions) - 50% / 50%

■ Java OCA Test Exam IV - 64% correct (124/191)
worst3
  1. Exceptions (19 questions) - 26% / 74%
  2. Inheritance (25 questions) - 44% / 56%
  3. Java API (27 questions) - 59% / 41%

추후 검토
40, Q4103
75, Q4185
111, Q4141


■ Java OCA Test Exam V - 73% correct (140/191)
worst3
  1. Inheritance (24 questions) - 58% / 42%
  2. Java API (28 questions) - 64% / 36%
  3. Arrays (14 questions) - 64% / 36%

Java Basics (18 questions) - 78% / 22%
Data Types (20 questions) - 85% / 15%
Operators & Decision Constructs (20 questions) - 95% /5%
Arrays (14 questions) - 64% / 36%
Loops (22 questions) - 82% / 18%
Methods & Encapsulation (25 questions) - 72% / 28%
Inheritance (24 questions) - 58% / 42%
Exceptions (20 questions) - 65% / 35%
Java API (28 questions) - 64% / 36%


■ Java OCA Test Exam VI - 61% correct (117/191)
worst3
  1. Java API (26 questions) - 42% / 58%
  2. Methods & Encapsulation (27 questions) - 52% / 48%
  3. Arrays (14 questions) - 57% / 43%

Java Basics (18 questions) - 67% / 33%
Data Types (21 questions) - 62% / 38%
Operators & Decision Constructs (19 questions) - 84% / 16%
Java API (26 questions) - 42% / 58%
Arrays (14 questions) - 57% / 43%
Loops (22 questions) - 59% / 41%
Methods & Encapsulation (27 questions) - 52% / 48%
Inheritance (22 questions) - 64% / 36%
Exceptions (22 questions) - 73% / 27%


오답 Notes
Q2126
A static method can not be overridden.
At compile time the call() method of the reference type Phone
will be bind to the object and it cannot be overridden
by the call() method of the object type SmartPhone at runtime.

Q2112
This is a correct example of code that uses a lambda.

Q2185
checkScore(list, (Examinee e) -> { return e.getScore() > 65; });
checkScore(list, e -> e.getScore() > 65);

java.io.IOException / NumberFormatException programmtically
NullPointerException / ArrayIndexOutOfBoundsException / ExceptionInInitializerError JVM

Q2100
A constructor can not have a return value. / can not be final. / can not be static.
A constructor can have any access modifier
(protected in a final class works, but doesn't make much sense).

Q2132 
First of all, interfaces can only contain abstract, final, and default methods.
The method fly() defined in CanFly is not marked static or default 
and defines an implementation, an empty {}, 
meaning it cannot be assumed to be abstract;
therefore, the code does not compile.

Next, the implementation of fly(int speed) in the Bird class also does not compile,
but not because of the signature. The method body fails to return an int value.
Since it is an overloaded method,
if it returned a value it would compile without issue.

Finally, the Eagle class does not compile because it extends the Bird class,
which is marked final and therefore, cannot be extended.
For these three reasons,

Three is the correct answer.

Q2132 완전 이해 X

Q2158
Notice that all the exceptions thrown or caught are unchecked exceptions.

First, the ClassCastException is thrown in the try block and caught by the second catch block
since it inherits from RuntimeException, not IllegalArgumentException.

Next, a NullPointerException is thrown, but before it can be returned the finally block
is executed and a RuntimeException replaces it.

The application exits and the caller sees the RuntimeException in the stack trace.
If the finally block did not throw any exceptions, then NullPointerException would be the correct answer.


Q2131
The object type relates to the attributes of the object that exist in memory,
while the reference type dictates how the object is able to be used by the caller.

Q2089
In a for loop, the type is only allowed to be specified once.

Q2186
Predicate - functional programming interface with a single parameter and returns a boolean.
Lambda expressions with one parameter are allowed to omit the parentheses around the parameter list.
The return statement is optional when a single statement is in the body.
A return statement must be used if braces are included around the body.
The type is Integer in the predicate and int in the lambda.
Autoboxing works for collections of inferring predicates.
If these two were changed to Integer, they would be correct.

test((i) -> i == 5)
test(i -> i == 5)
test((i) -> {return i == 5;})
test(i -> {return i == 5;})
test((Integer i) -> i == 5)
test((Integer i) -> {return i == 5;}))

Q2130
An abstract method cannot include the final or private method.
The default keyword applies to concrete interface methods, not abstract methods.
The protected, package-private, and public access modifiers can each be applied to abstract methods.

Q2137
jogger.move(); doesn't compile, because there is no move() method in Jogger.
(FitnessBuff)jogger.move(); doesn't compile, because you need to cast the object
and not the return value of a method call.
It needs to look like: ((FitnessBuff)jogger).move();
(FitnessBuff)runner.move(); Same here. It needs to look like: ((FitnessBuff)runner).move();


Q5142
169 Which statements are true for both abstract classes and interfaces?(Choose four)

Both inherit java.lang.Object X
Neither can be instantiated directly. O
Both can contain static methods. O
Both can contain default methods. X
Both can contain public static final variables. O
Both can be extended using the extends keyword. O
All methods within them are assumed to be abstract. X

Explanation:
An abstract class may contain concrete methods.
Since Java 8, interfaces may also contain concrete methods
in form of static or default methods.

Although all variables in interfaces
are assumed to be public static final,
abstract classes may contain them as well.

Both abstract classes and interfaces
can be extended with the extends keyword.

Only interfaces can contain default methods.

Both abstract classes and interfaces can contain static methods.

Both structures require a concrete subclass to be instantiated.

Finally, though an instance of an object
that implements an interface inherits java.lang.
Object, the interface itself doesn’t.

Otherwise, Java would support multiple inheritance for objects, which it doesn’t.


Q5062 176
How do you determine the number of elements in an array?

buses.size() X
buses.size X
buses.length O
buses.length() X

Explanation:
Arrays use the length variable to determine the number of elements.
For an ArrayList size() would have been the answer.
length() is used by String and StringBuilder.

Q5149 14
Which statements are true. (Choose four)

Your selection is correct
A checked exception must be caught explicitly. O
In multi catch blocks, the subclass exception handler 
must be caught after the superclass exception handler. X
A try block must be followed by either a catch or finally block. O
In multi catch blocks, the subclass exception handler
must be caught before the superclass exception handler. O
The Exception class is the superclass of all errors 
and exceptions in the java language.  X
A single catch block can handle more than one type of exception. O

Try it yourself and explanation:
import java.io.BufferedReader;
import java.io.FileReader;

public class App {
    public static void main(String[] args) {
        // "A single catch block can handle more 
        // than one type of exception."
        try {
            String str1 = "Hello";
            // System.out.println(str1.charAt(10));
            String str2 = null;
            System.out.println(str2.length());
        } catch (StringIndexOutOfBoundsException | NullPointerException e) {
            System.out.println("Something is wrong with the string.");
        }
 
        // "A try block must be followed by either a catch or finally block."
        // try {}
        // Compile error: 
        // 'try' without 'catch', 'finally' or resource declarations
 
        // "A checked exception must be caught explicitly."
        // BufferedReader br = 
        //     new BufferedReader(new FileReader("MeNotThere.txt"));
        // Compile error:
        // unreported exception java.io.FileNotFoundException;
        // must be caught or declared to be thrown
 
        // "In multi catch blocks, the subclass exception handler
        // must be caught before the superclass exception handler."
        try {
            int[] arr = {1, 2, 3};
            // System.out.println(arr[9]);
            String text = "Hello";
            System.out.println(text.charAt(9));
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index problem!");
        } catch (IndexOutOfBoundsException e) {
            System.out.println("Index problem!");
        }
 
        // "In multi catch blocks, the subclass exception handler
        // must be caught after the superclass exception handler."
        // This is wrong:
        // Compile error:
        // exception java.lang.ArrayIndexOutOfBoundsException
        // has already been caught
        try {
            int[] arr = {1, 2, 3};
            // System.out.println(arr[9]);
            String text = "Hello";
            System.out.println(text.charAt(9));
        } catch (IndexOutOfBoundsException e) {
            System.out.println("Array index problem!");
        }
        // catch (ArrayIndexOutOfBoundsException e) {
        //     System.out.println("Index problem!"); }
 
        // "The Exception class is the superclass of all errors
        // and exceptions in the java language."
        // This is wrong, because Throwable is the superclass
        // of all errors and exceptions in the java language:
        try {}
        catch (Throwable t) {}
    }
}
